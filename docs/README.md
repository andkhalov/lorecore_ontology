# Система универсальных JSON-схем для управления знаниями и контентом QUANT_v1 (vq1)

## Введение

В рамках разработки системы управления знаниями и контентом, способной работать с разнородными типами данных, необходимо создать унифицированный способ описания и валидации объектов. Для этого была разработана система JSON-схем, которая определяет структуру и семантику основных объектов системы.

**Ключевые цели:**
- Обеспечить единообразие представления данных
- Облегчить валидацию и контроль качества данных
- Сделать систему расширяемой и адаптируемой к новым типам объектов
- Улучшить взаимопонимание между различными компонентами и разработчиками


**Назначение и обоснование:**

Универсальная JSON‑схема (контейнер QUANT) и её специализированные расширения разработаны для того, чтобы:

- **Обеспечить консистентность данных.**
    Все объекты, независимо от источника (внутренние документы, внешние знания, треды, сообщения, QA‑пары, товары, агенты, проекты, объекты аугментации), следуют единому контракту. Это позволяет микросервисам (ETL, векторизация, GraphDB, QA‑сервис, аналитика) работать с данными без необходимости адаптировать различные форматы.

- **Упростить интеграцию между компонентами.**
    Унифицированная схема служит «языком обмена» между системами. Например, когда QA‑сервис запрашивает релевантные фрагменты у Vector Store, он получает ID и метаданные, строго соответствующие контракту, что позволяет точно сопоставлять результаты в поиске с записями в GraphDB.

- **Обеспечить масштабируемость и расширяемость.**
    Базовая структура (QUANT) определяет обязательный набор универсальных полей (таких как _id, json_version, created_at, type, accessLevel и т.д.). Дополнительно для каждого типа объекта существуют специализированные схемы. С использованием конструкции allOf (или схожих механизмов наследования) можно легко добавлять новые типы данных и новые поля без необходимости менять существующий код, что существенно снижает риск регрессий при дальнейшем развитии системы.

- **Поддерживать контроль версий и управление изменениями.**
    Поле json_version позволяет отслеживать изменения схемы. Это гарантирует, что при обновлении объекта или изменении бизнес‑логики система сможет корректно обработать данные в старом и новом формате.

- **Документировать связь с онтологией.**
    Поле ontological_refs (и при необходимости дополнительные поля вроде ontology_mapping) позволяют явно связывать объекты с концепциями и сущностями, определёнными в онтологии (пространство имен: http://botlab.com/ont#). Это упрощает интеграцию с GraphDB, позволяет строить семантические связи и использовать полученные данные для семантического поиска и аналитики.


______

### Базовая схема QUANT
Схема лежит в файле `vq1_quant_schema.json`.
Ядром системы является базовая схема `QUANT` (Quantum Object), которая определяет общие поля и метаданные для всех объектов:

```json
{
  "jsonVersion": "Версия JSON схемы для поддержки совместимости",
  "_id": "Уникальный идентификатор объекта, UUID5",
  "createdAt": "Дата и время создания объекта, ISO8601",
  "updatedAt": "Дата и время последнего обновления объекта, ISO8601",
  "type": "Тип объекта для маршрутизации и обработки",
  "accessLevel": "Уровень доступа, от 0 (открытый) до 6 (только для админа)",
  "fromAccount": "Аккаунт клиента, к которому относится объект",
  "fromProject": "Проект (опционально, null для общих объектов)",
  "graphRecord": "URI объекта в GraphDB (опционально)",
  "vectorised": "ID объекта в векторном хранилище (опционально)",
  "version": "Порядковый номер версии объекта",
  "language": "Язык содержимого объекта, 'ru' или 'en'",
  "primaryModality": "Указывает основную модальность объекта (текст, аудио, видео и т.д.), описывается как UUID URI в графе",
  "secondaryModality": "Указывает дополнительную модальность объекта, описывается как UUID URI в графе",
  "processingStage": "Стадия обработки: created, augmented, completed",
  "hasParrent": "Ссылка на родительский объект (опционально)"
}
```

Поля `_id`, `createdAt`, `type`, `accessLevel`, `fromAccount`, `version`, `primaryModality` и `processingStage` являются обязательными для всех объектов.

______

## Специфические схемы объектов

Для каждого типа объектов (`type`) определена своя JSON-схема, которая расширяет базовую схему `QUANT` специфическими полями. Эти схемы хранятся в отдельных файлах для удобства поддержки и расширения.


### DOC - Документ

Схема `vq1_doc_schema.json` описывает объекты типа "Документ". Это могут быть файлы, загруженные пользователями, или документы, сгенерированные самой системой (например, отчеты).

```json
{
  "link": "Ссылка или путь до файла",
  "storage": "Адрес хранилища",
  "fileName": "Имя файла",
  "fileHash": "Хэш файла для контроля изменений",
  "size": "Размер файла в килобайтах (целое число)",
  "postedBy": "ID агента, который загрузил/отправил документ",
  "createdBy": "ID AI агента, если документ сгенерирован (или null)",
  "documentType": "Формат или расширение исходного документа (PDF, DOCX и т.д.)"
}
```

Пример объекта DOC:
```json
{
  "_id": "eafc1165-dd2e-5fb8-8b5f-2209ab7ef2a9",
  "type": "DOC",
  "fileName": "Отчет по продажам.pdf",
  "fileHash": "e3b0c44298fc1149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
  "size": 1024,  
  "postedBy": "94d948d6-1e5f-561b-b694-afe1b4f64fd0",
  "documentType": "application/pdf"
}
```

Поля `fileName`, `fileHash`, `postedBy` и `documentType` определены как обязательные в схеме `DOC`.


### KNOWLEDGE - Внешние источники знаний

Схема `vq1_knowledge_schema.json` используется для объектов типа "Внешний источник знаний". Это текстовые документы, которые загружаются в систему для пополнения базы знаний. Они проходят процесс ETL (Extract, Transform, Load) для извлечения полезной информации.

```json
{
  "fileName": "Имя исходного файла",
  "fileHash": "Хэш файла для контроля изменений",
  "link": "Внешний URL источника, если применимо (или null)"
}
```

Пример объекта KNOWLEDGE:
```json
{
  "_id": "97a39063-4ba7-5d1f-9e9c-3a5d071f559c",  
  "type": "KNOWLEDGE",
  "fileName": "Википедия_статья_о_машинном_обучении.txt",
  "fileHash": "f58e5f2b4c4fd11b3c80fc3897943da9e7254d31c2fb45c3a815456a930f5093"
}
```
Поля `fileName` и `fileHash` являются обязательными для объектов типа KNOWLEDGE.


### CHUNK - Фрагменты текста

Схема `vq1_chunk_schema.json` описывает объекты типа "Фрагмент текста" или "Чанк". Это части большого текстового документа (`KNOWLEDGE`), которые удобно обрабатывать и анализировать по отдельности.

```json
{
  "originKnowledge": "Уникальный идентификатор исходного KNOWLEDGE объекта (UUID)",
  "keyWord": "Список ключевых слов, извлеченных из чанка (массив от 0 до 5 строк)",
  "chunkNumber": "Номер чанка в последовательности (целое число)"
}
```

Пример объекта CHUNK:
```json
{
  "_id": "4c68a4e7-9a86-5ed7-9c74-5c5e8f2b8f58",
  "type": "CHUNK",
  "originKnowledge": "97a39063-4ba7-5d1f-9e9c-3a5d071f559c",
  "keyWord": ["машинное обучение", "индуктивное", "дедуктивное"],
  "chunkNumber": 2
}
```
Поля `originKnowledge`, `keyWord` и `chunkNumber` обязательны для объектов `CHUNK`. Поле `originKnowledge` ссылается на объект `KNOWLEDGE`, из которого был получен данный фрагмент.


### THREAD - Треды сообщений

Схема `vq1_theread_schema.json` используется для объектов типа "Тред". Тред объединяет несколько сообщений (`MESSAGE`) в логически связанную дискуссию или диалог.

```json
{
  "media": "Сфера, где произошёл тред (telegram, twitter, whatsapp, AMO, CRM, VOIP)",
  "streamed": "Дополнительный канал, куда транслируется тред, если имеется (или null)",
  "updatedAt": "Дата и время последнего сообщения в треде (ISO8601)"
}
```

Пример объекта THREAD:
```json
{
  "_id": "774f601c-b63b-5843-8b48-0139d5e81d0e",
  "type": "THREAD",
  "media": "telegram",
  "streamed": "CRM",
  "updatedAt": "2025-06-22T19:10:25.147+03:00"  
}
```
Обязательными полями для объекта `THREAD` являются `media` (платформа, где происходит общение) и `updatedAt` (временная метка последнего сообщения в треде).


### MESSAGE - Сообщения

Схема `vq1_message_schema.json` описывает объекты типа "Сообщение". Сообщения могут быть как частью треда, так и независимыми.

```json
{
  "fromThread": "Идентификатор треда, если сообщение является его частью (UUID или null)",
  "text": "Текст сообщения",
  "postedBy": "ID отправителя сообщения (агент)",
  "link": "Ссылка на сообщение на платформе (или null)",
  "reply": "ID сообщения, на которое данное сообщение является ответом (UUID или null)",
  "hasReactions": {
    "likes": "Количество лайков (целое число, минимум 0)",
    "views": "Количество просмотров (целое число, минимум 0)",
    "reactions": "Другие типы реакций (объект)"
  },
  "attachment": "ID прикрепленного документа из типа DOC (или null)",
  "media": "Платформа, откуда получено сообщение (telegram, twitter и т.д., или null)",
  "hasIntention": "Намерение сообщения: comment, question, answer, request",
  "hasSentiment": "Оценка тональности сообщения: neutral, negative, positive"
}
```

Пример объекта MESSAGE:
```json
{
  "_id": "1dd0f7b3-7efc-56a1-b628-6fe9cd59c159",
  "type": "MESSAGE",  
  "fromThread": "774f601c-b63b-5843-8b48-0139d5e81d0e",
  "postedBy": "94d948d6-1e5f-561b-b694-afe1b4f64fd0",
  "reply": null,
  "hasIntention": "question",
  "hasSentiment": "neutral"
}
```
Обязательные поля для `MESSAGE`: `postedBy` (агент, который запостил сообщение), `hasIntention` (намерение сообщения), `hasSentiment` (тональность).


### AGENT - Агенты (люди и боты)

Схема `vq1_agent_schema.json` используется для описания агентов - как реальных людей, так и ботов, которые взаимодействуют с системой.

```json
{
  "agentNature": "Характер агента: PERSON или AI",
  "hasName": "Имя агента, как он представляется пользователям",
  "agentRole": "Роль агента: CUSTOMER, USER, SALES, CONSULTANT, AMBASSADOR, указывается класс из графа",
  "gender": "Пол агента: male, female, other",
  "age": "Возраст агента (целое число)",
  "agentContacts": "Контактные данные агента",
  "hasSkill": "Список навыков агента",
  "agentPolicy": "Стратегия или мастер-промпт для AI агента (опционально) в виде объекта в графе",
  "agentDescription": "Общее описание агента, его характеристика"
}
```

Пример объекта AGENT:
```json
{
  "_id": "94d948d6-1e5f-561b-b694-afe1b4f64fd0",
  "type": "AGENT",
  "agentNature": "94d948d6-1e5f-561b-b694-afe1b4f64fd0",
  "agentName": "Мария Сидорова", 
  "agentRole": "94d948d6-1e5f-561b-b694-afe1b4f64fd0",
  "agentContacts": {
    "email": "maria@example.com",
    "phone": "+79991234567"
  },
  "hasSkills": ["94d948d6-1e5f-561b-b694-afe1b4f64fd0", "94d948d6-1e5f-561b-b694-afe1b4f64fd0"]
}
```
Поля `agentNature`, `hasName` и `agentRole` являются обязательными для объектов `AGENT`.


### PROJECT - Проекты

Схема `vq1_project_schema.json` описывает объекты типа "Проект". Проекты позволяют логически группировать объекты и управлять доступом к ним.

```json
{
  "hasName": "Имя проекта",
  "started": "Дата начала проекта (ISO8601)",
  "projectGoal": "Цель проекта",
  "dueDate": "Срок выполнения проекта, если есть (ISO8601 или null)",
  "projectStatus": "Текущий статус проекта: complete, inProgress, cancelled, blocked"
}
```

Пример объекта PROJECT:
```json
{  
  "_id": "2eaa56f6-d479-5480-b3de-ff90d688f448",
  "type": "PROJECT",
  "projectName": "Внедрение чат-бота",
  "started": "2025-01-15T00:00:00.000+03:00",
  "hasGoal": "Разработать и внедрить чат-бота для техподдержки",
  "hasStatus": "2eaa56f6-d479-5480-b3de-ff90d688f448"
}
```
Поля `projectName`, `started`, `hasGoal` и `hasStatus` обязательны для объектов `PROJECT`.


### AUGMENTATION - Метаданные и аугментация

Схема `vq1_augmentation_schema.json` используется для объектов, содержащих дополнительные метаданные и результаты семантического анализа других объектов (аугментации).

```json
{
  "originObject": "ID исходного объекта, для которого выполнена аугментация (UUID)",
  "hasTopic": "Тема аугментации",
  "hasDomain": "Область знаний",
  "augSummary": "Суммарное описание объекта (до 512 токенов)",
  "generatedBy": "Модель или источник, который сгенерировал эту аугментацию",
  "keyWord": "Список ключевых слов, извлеченных с помощью LLM (массив строк)",
  "keyFact": "Список ключевых фактов, извлеченных из исходного текста (массив строк)"
}
```

Пример объекта AUGMENTATION:
```json
{
  "_id": "8f6e1b04-7df6-5ce0-b5d5-cfe9a76e7a31",  
  "type": "AUGMENTATION",
  "originObject": "97a39063-4ba7-5d1f-9e9c-3a5d071f559c",
  "hasTopic": "Машинное обучение",  
  "hasDomain": "Искусственный интеллект",
  "hasSummary": "В статье рассматриваются основные понятия и методы машинного обучения...",
  "keyWord": ["машинное обучение", "искусственный интеллект", "нейронные сети"]   
}
```
Все поля (`originObject`, `hasTopic`, `hasDomain`, `hasSummary`, `generatedBy`, `keyWord`, `keyFact`) обязательны для объектов `AUGMENTATION`.


### UNIT - Товары и услуги

Схема `vq1_unit_schema.json` описывает объекты типа "Единица товара или услуги". Используется для управления коммерческим контентом.

```json
{
  "hasName": "Имя товара или услуги",
  "hasPrice": "Цена товара или услуги (число)",
  "haStatus": "Статус товара (продается, не продается, на складе и т.д.)",
  "hasCategory": "Категория товара, если применимо",
  "hasDescription": "Детальное описание товара (объект с произвольными ключами-строками)"
}
```

Пример объекта UNIT:
```json
{
  "_id": "ce1c9c04-2d63-5cbe-9acf-ab518f69b1a7",
  "type": "UNIT",
  "hasName": "Лицензия на ПО Х", 
  "hasPrice": 9999.99,
  "hasStatus": "ce1c9c04-2d63-5cbe-9acf-ab518f69b1a7", 
  "hasCategory": "Программное обеспечение",
  "hasDescription": "ce1c9c04-2d63-5cbe-9acf-ab518f69b1a7"
}
```
Поля `hasName`, `hasPrice`, и `hasStatus` обязательны для объектов `UNIT`.


### QA - Пары "вопрос-ответ"

Схема `vq1_qa_schema.json` используется для хранения пар "вопрос-ответ", которые могут использоваться для обучения модели вопросно-ответной системы.

```json
{
  "topic": "Тема или суть вопроса",
  "evaluation": "Оценка качества ответа (рейтинг или комментарий)",
  "reuse": "Количество повторных использований данного ответа (целое число, минимум 0)",
  "hasQuestion": "ID вопроса, вопрос это любое сообщение с Intention QUESTION",
  "hasAnswer": "ID ответа"
}
```

Пример объекта QA:
```json
{
  "_id": "3b9f2e7a-b3e3-56bf-9246-7bf0b8e8b6a3",
  "type": "QA",
  "topic": "Условия доставки",
  "evaluation": "4",
  "reuse": 12
}
```
Поля `topic`, `evaluation`, и `reuse` обязательны для объектов `QA`.


__________


## Как использовать схемы

1. При создании нового объекта в системе необходимо руководствоваться соответствующей JSON-схемой для его типа. Это гарантирует, что объект будет содержать все необходимые поля и иметь валидную структуру.
2. Перед сохранением объекта в базе данных рекомендуется выполнить валидацию его структуры по JSON-схеме. Это можно сделать с помощью библиотек для работы с JSON Schema, например, ajv для Node.js. Пример использования:
```javascript
const Ajv = require('ajv');
const ajv = new Ajv();

const quantSchema = require('./vq1_quant_schema.json');
const docSchema = require('./vq1_doc_schema.json');

const validate = ajv.addSchema(quantSchema).compile(docSchema);

const doc = {
  // ...
};

const valid = validate(doc);
if (!valid) console.log(validate.errors);
```
3. Для интеграции схем в пользовательский интерфейс можно использовать библиотеки, которые генерируют формы ввода на основе JSON Schema, такие как react-jsonschema-form. Это позволит ускорить разработку и гарантировать согласованность интерфейса с бэкенд-моделью.
4. При внесении изменений в структуру объектов необходимо в первую очередь обновлять соответствующие JSON-схемы. Следует избегать несогласованных изменений в коде, которые нарушают контракт, описанный схемой. Это поможет поддерживать целостность системы и избегать ошибок.


_________

## Применение на практике


### Пример 1. Объект документа (DOC)

При загрузке файла документ не только сохраняется в MongoDB, но и его метаданные (имя файла, хэш, путь, размер, дата последнего изменения) фиксируются в документе. Дополнительно через поле `graphRecord` устанавливается связь с онтологией, а через `vectorised` – с векторным хранилищем. Такой подход позволяет легко отследить историю изменений документа, определить, когда документ обновлялся, а также получить релевантный контекст для Retrieval-Augmented Generation (RAG).
```json
{
  "jsonVersion": "1.0",
  "_id": "6c8ebe57-d19b-520f-acd2-c50eafd70d3d",
  "createdAt": "2025-04-14T11:20:49.340134Z",
  "type": "DOC",
  "accessLevel": 4,
  "fromAccount": "client_123",
  "fromProject": "default",
  "graphRecord": "http://botlab.com/ont#Record456",
  "vectorised": null,
  "version": 0,
  "language": "en",
  "primaryModality": "6c8ebe57-d19b-520f-acd2-c50eafd70d3m",
  "processingStage": "created",
  "hasParrent": null,
  "ontologicalRefs": [
    "http://botlab.com/ont#DocumentCategory:Internal"
  ],
  "link": "https://storage.botlab.com/documents/QE-Privacy.pdf",
  "storage": "botlab_file_storage_1",
  "filename": "QE- Website Privacy Notice.pdf",
  "filehash": "98776167a7cd26fc83e4d0ba8f138742",
  "size": 256,
  "lastChange": "2025-04-14T11:10:00Z",
  "postedBy": "agent_001",
  "createdBy": null,
  "documentType": "PDF"
}
```

### Пример 2. Объект треда (THREAD) с вложенными сообщениями

Когда речь идёт о диалогах или цепочках сообщений, тред представляет собой базовый объект, который расширяется полями, характерными для дискуссии (например, media, streamed и lastMessage). Отдельные сообщения хранятся как самостоятельные объекты с полями, такими как текст, автор, реакции и дополнительные поля для настроения (sentiment, score). Благодаря единой схеме все эти объекты могут быть интегрированы между собой: например, сообщение ссылается на тред через поле `threadID`, а тред хранит список связанных сообщений (или же сообщения хранятся отдельно, но связаны через родительский ID).
```json
{
  "jsonVersion": "1.0",
  "_id": "fc123456-7890-1234-abcd-ef0123456789",
  "createdAt": "2025-04-14T12:00:00Z",
  "type": "THREAD",
  "accessLevel": 1,
  "fromAccount": "client_123",
  "fromProject": "default",
  "graphRecord": "http://botlab.com/ont#Record789",
  "vectorised": null,
  "version": 0,
  "language": "ru",
  "primaryModality": "6c8ebe57-d19b-520f-acd2-c50eafd70d3m",
  "processingStage": "augmented",
  "parentId": null,
  "ontologicalRefs": [
    "http://botlab.com/ont#ThreadCategory:Support"
  ],
  "media": "telegram",
  "streamed": "CRM_system",
  "updatedAt": "2025-04-14T12:30:00Z"
}
```
Пример отдельного сообщения, связанного с тредом:
```json
{
  "jsonVersion": "1.0",
  "_id": "ae234567-8901-2345-bcde-f01234567890",
  "createdAt": "2025-04-14T12:05:00Z",
  "type": "MESSAGE",
  "accessLevel": 1,
  "fromAccount": "client_123",
  "fromProject": "default",
  "graphRecord": null,
  "vectorised": null,
  "version": 0,
  "language": "ru",
  "primaryModality": "6c8ebe57-d19b-520f-acd2-c50eafd70d3m",
  "processingStage": "completed",
  "hasParrent": "fc123456-7890-1234-abcd-ef0123456789",
  "ontological_refs": [
    "http://botlab.com/ont#MessageCategory:Question"
  ],
  "threadID": "fc123456-7890-1234-abcd-ef0123456789",
  "text": "Здравствуйте, у меня проблема с заказом.",
  "author": "agent_002",
  "username": "ИванПетров",
  "link": "https://t.me/c/123456789/100",
  "reply": null,
  "reactions": {
    "likes": 3,
    "views": 20,
    "reactions": {
      "love": 1
    }
  },
  "attachment": null,
  "media": "telegram",
  "messageIntention": "question",
  "sentiment": "neutral",
  "score": 0.85
}
```

### Пример 3. Объект аугментации (AUGMENTATION)

Объект аугментации – синтетический, созданный на основе исходного объекта (например, документа или треда). Он содержит результаты обработки, такие как суммаризация, ключевые слова и факты.
```json
{
  "jsonVersion": "1.0",
  "_id": "bc345678-9012-3456-cdef-012345678901",
  "createdAt": "2025-04-14T12:45:00Z",
  "type": "AUGMENTATION",
  "accessLevel": 0,
  "fromAccount": "client_123",
  "fromProject": "default",
  "graphRecord": "http://botlab.com/ont#AugmentationRecord001",
  "vectorised": null,
  "version": 0,
  "language": "en",
  "primaryModality": "6c8ebe57-d19b-520f-acd2-c50eafd70d3m",
  "processingStage": "completed",
  "hasParrent": null,
  "ontologicalRefs": [
    "http://botlab.com/ont#AugmentationCategory:Summary"
  ],
  "originObject": "6c8ebe57-d19b-520f-acd2-c50eafd70d3d",
  "topic": "Referral Program Overview",
  "domain": "legal",
  "summary": "Документ описывает условия реферальной программы, включая права и обязанности участников, а также методы начисления вознаграждения.",
  "generatedBy": "OpenAI-GPT-4",
  "keyWord": ["referral", "terms", "reward", "program"],
  "keyFact": [
    "Участники должны соответствовать возрастным требованиям",
    "Выплаты осуществляются в USDT"
  ]
}
```

_________

## Заключение

Эта документация и набор JSON‑схем дают нам четкий контракт для обмена данными между всеми микросервисами системы. Универсальный контейнер (QUANT) с общими полями задаёт основу, а специфические схемы для каждого типа объектов (DOC, KNOWLEDGE, CHUNK, THREAD, MESSAGE, QA, UNIT, AGENT, PROJECT, AUGMENTATION) расширяют базовый формат и определяют дополнительные атрибуты, характерные для конкретного типа данных. Использование единого пространства идентификаторов, уровня доступа, привязки к аккаунтам и проектов, а также явное указание на онтологию (через URI с пространством имен http://botlab.com/ont#) позволяет обеспечить консистентность, масштабируемость и гибкость системы.

Каждый объект снабжается метаданными, которые позволяют отслеживать его обработку, изменения, связи с другими объектами (например, parent_id) и интеграцию с компонентами, такими как Vector Store и GraphDB. Это основа всей системы, которая гарантирует, что **независимо от источника данных** или типа объекта, информация будет передана, обработана и сохранена в едином согласованном формате.

Эта спецификация – фундамент, на котором строятся дальнейшие компоненты системы, и её корректное определение критически важно для стабильной работы всей архитектуры.